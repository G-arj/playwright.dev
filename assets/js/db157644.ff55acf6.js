"use strict";(self.webpackChunkplaywright_dev=self.webpackChunkplaywright_dev||[]).push([[3013],{14401:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return p},contentTitle:function(){return u},metadata:function(){return c},toc:function(){return d},default:function(){return g}});var s=n(87462),a=n(63366),i=(n(67294),n(3905)),o=n(26396),r=n(58215),l=["components"],p={id:"test-api-testing",title:"API testing"},u=void 0,c={unversionedId:"test-api-testing",id:"version-1.16/test-api-testing",isDocsHomePage:!1,title:"API testing",description:"Playwright can be used to get access to the REST API of your application.",source:"@site/versioned_docs/version-1.16/test-api-testing.mdx",sourceDirName:".",slug:"/test-api-testing",permalink:"/docs/test-api-testing",tags:[],version:"1.16",frontMatter:{id:"test-api-testing",title:"API testing"},sidebar:"version-1.16/docs",previous:{title:"Annotations",permalink:"/docs/test-annotations"},next:{title:"Assertions",permalink:"/docs/test-assertions"}},d=[{value:"Writing API Test",id:"writing-api-test",children:[{value:"Configuration",id:"configuration",children:[],level:3},{value:"Writing tests",id:"writing-tests",children:[],level:3},{value:"Setup and teardown",id:"setup-and-teardown",children:[],level:3}],level:2},{value:"Using request context",id:"using-request-context",children:[],level:2},{value:"Sending API requests from UI tests",id:"sending-api-requests-from-ui-tests",children:[{value:"Establishing preconditions",id:"establishing-preconditions",children:[],level:3},{value:"Validating postconditions",id:"validating-postconditions",children:[],level:3}],level:2},{value:"Reusing authentication state",id:"reusing-authentication-state",children:[],level:2}],h={toc:d};function g(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,s.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Playwright can be used to get access to the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Representational_state_transfer"},"REST")," API of your application."),(0,i.kt)("p",null,"Sometimes you may want to send requests to the server directly from Node.js without loading a page and running js code in it. A few examples where it may come in handy:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Test your server API."),(0,i.kt)("li",{parentName:"ul"},"Prepare server side state before visiting the web application in a test."),(0,i.kt)("li",{parentName:"ul"},"Validate server side post-conditions after running some actions in the browser.")),(0,i.kt)("p",null,"All of that could be achieved via ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-apirequestcontext",title:"APIRequestContext"},"APIRequestContext")," methods."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#writing-api-test"},"Writing API Test"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#configuration"},"Configuration")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#writing-tests"},"Writing tests")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#setup-and-teardown"},"Setup and teardown")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#using-request-context"},"Using request context")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#sending-api-requests-from-ui-tests"},"Sending API requests from UI tests"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#establishing-preconditions"},"Establishing preconditions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#validating-postconditions"},"Validating postconditions")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#reusing-authentication-state"},"Reusing authentication state"))),(0,i.kt)("h2",{id:"writing-api-test"},"Writing API Test"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-apirequestcontext",title:"APIRequestContext"},"APIRequestContext")," can send all kinds of HTTP(S) requests over network."),(0,i.kt)("p",null,"The following example demonstrates how to use Playwright to test issues creation via ",(0,i.kt)("a",{parentName:"p",href:"https://docs.github.com/en/rest"},"GitHub API"),". The test suite will do the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create a new repository before running tests."),(0,i.kt)("li",{parentName:"ul"},"Create a few issues and validate server state."),(0,i.kt)("li",{parentName:"ul"},"Delete the repository after running tests.")),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"GitHub API requires authorization, so we'll configure the token once for all tests. While at it, we'll also set the ",(0,i.kt)("inlineCode",{parentName:"p"},"baseURL")," to simplify the tests. You can either put them in the configuration file, or in the test file with ",(0,i.kt)("inlineCode",{parentName:"p"},"test.use()"),"."),(0,i.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// playwright.config.ts\nimport { PlaywrightTestConfig } from '@playwright/test';\n\nconst config: PlaywrightTestConfig = {\n  use: {\n    // All requests we send go to this API endpoint.\n    baseURL: 'https://api.github.com',\n    extraHTTPHeaders: {\n      // We set this header per GitHub guidelines.\n      'Accept': 'application/vnd.github.v3+json',\n      // Add authorization token to all requests.\n      // Assuming personal access token available in the environment.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    },\n  }\n};\nexport default config;\n"))),(0,i.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// playwright.config.js\n// @ts-check\n/** @type {import('@playwright/test').PlaywrightTestConfig} */\nconst config = {\n  use: {\n    // All requests we send go to this API endpoint.\n    baseURL: 'https://api.github.com',\n    extraHTTPHeaders: {\n      // We set this header per GitHub guidelines.\n      'Accept': 'application/vnd.github.v3+json',\n      // Add authorization token to all requests.\n      // Assuming personal access token available in the environment.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    },\n  }\n};\nmodule.exports = config;\n")))),(0,i.kt)("h3",{id:"writing-tests"},"Writing tests"),(0,i.kt)("p",null,"Playwright Test comes with the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"request")," fixture that respects configuration options like ",(0,i.kt)("inlineCode",{parentName:"p"},"baseURL")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"extraHTTPHeaders")," we specified and is ready to send some requests."),(0,i.kt)("p",null,"Now we can add a few tests that will create new issues in the repository."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const REPO = 'test-repo-1';\nconst USER = 'github-username';\n\ntest('should create a bug report', async ({ request }) => {\n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {\n    data: {\n      title: '[Bug] report 1',\n      body: 'Bug description',\n    }\n  });\n  expect(newIssue.ok()).toBeTruthy();\n\n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);\n  expect(issues.ok()).toBeTruthy();\n  expect(await issues.json()).toContainEqual(expect.objectContaining({\n    title: '[Bug] report 1',\n    body: 'Bug description'\n  }));\n});\n\ntest('should create a feature request', async ({ request }) => {\n  const newIssue = await request.post(`/repos/${USER}/${REPO}/issues`, {\n    data: {\n      title: '[Feature] request 1',\n      body: 'Feature description',\n    }\n  });\n  expect(newIssue.ok()).toBeTruthy();\n\n  const issues = await request.get(`/repos/${USER}/${REPO}/issues`);\n  expect(issues.ok()).toBeTruthy();\n  expect(await issues.json()).toContainEqual(expect.objectContaining({\n    title: '[Feature] request 1',\n    body: 'Feature description'\n  }));\n});\n")),(0,i.kt)("h3",{id:"setup-and-teardown"},"Setup and teardown"),(0,i.kt)("p",null,"These tests assume that repository exists. You probably want to create a new one before running tests and delete it afterwards. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"beforeAll")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"afterAll")," hooks for that."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"test.beforeAll(async ({ request }) => {\n  // Create a new repository\n  const response = await request.post('/user/repos', {\n    data: {\n      name: REPO\n    }\n  });\n  expect(response.ok()).toBeTruthy();\n});\n\ntest.afterAll(async ({ request }) => {\n  // Delete the repository\n  const response = await request.delete(`/repos/${USER}/${REPO}`);\n  expect(response.ok()).toBeTruthy();\n});\n")),(0,i.kt)("h2",{id:"using-request-context"},"Using request context"),(0,i.kt)("p",null,"Behind the scenes, ",(0,i.kt)("a",{parentName:"p",href:"./api/class-fixtures#fixtures-request"},(0,i.kt)("inlineCode",{parentName:"a"},"request")," fixture")," will actually call ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-apirequest#api-request-new-context"},"apiRequest.newContext([options])"),". You can always do that manually if you'd like more control. Below is a standalone script that does the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"beforeAll")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"afterAll")," from above."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { request } = require('@playwright/test');\nconst REPO = 'test-repo-1';\nconst USER = 'github-username';\n\n(async () => {\n  // Create a context that will issue http requests.\n  const context = await request.newContext({\n    baseURL: 'https://api.github.com',\n  });\n\n  // Create a repository.\n  await context.post('/user/repos', {\n    headers: {\n      'Accept': 'application/vnd.github.v3+json',\n      // Add GitHub personal access token.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    },\n    data: {\n      name: REPO\n    }\n  });\n\n  // Delete a repository.\n  await context.delete(`/repos/${USER}/${REPO}`{\n    headers: {\n      'Accept': 'application/vnd.github.v3+json',\n      // Add GitHub personal access token.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    }\n  });\n})()\n")),(0,i.kt)("h2",{id:"sending-api-requests-from-ui-tests"},"Sending API requests from UI tests"),(0,i.kt)("p",null,"While running tests inside browsers you may want to make calls to the HTTP API of your application. It may be helpful if you need to prepare server state before running a test or to check some postconditions on the server after performing some actions in the browser. All of that could be achieved via ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-apirequestcontext",title:"APIRequestContext"},"APIRequestContext")," methods."),(0,i.kt)("h3",{id:"establishing-preconditions"},"Establishing preconditions"),(0,i.kt)("p",null,"The following test creates a new issue via API and then navigates to the list of all issues in the project to check that it appears at the top of the list."),(0,i.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { test, expect } from '@playwright/test';\n\nconst REPO = 'test-repo-1';\nconst USER = 'github-username';\n\n// Request context is reused by all tests in the file.\nlet apiContext;\n\ntest.beforeAll(async ({ playwright }) => {\n  apiContext = await playwright.request.newContext({\n    // All requests we send go to this API endpoint.\n    baseURL: 'https://api.github.com',\n    extraHTTPHeaders: {\n      // We set this header per GitHub guidelines.\n      'Accept': 'application/vnd.github.v3+json',\n      // Add authorization token to all requests.\n      // Assuming personal access token available in the environment.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    },\n  });\n})\n\ntest.afterAll(async ({ }) => {\n  // Dispose all responses.\n  await apiContext.dispose();\n});\n\ntest('last created issue should be first in the list', async ({ page }) => {\n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {\n    data: {\n      title: '[Feature] request 1',\n    }\n  });\n  expect(newIssue.ok()).toBeTruthy();\n\n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);\n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();\n  await expect(firstIssue).toHaveText('[Feature] request 1');\n});\n"))),(0,i.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// @ts-check\nconst { test, expect } = require('@playwright/test');\n\nconst REPO = 'test-repo-1';\nconst USER = 'github-username';\n\n// Request context is reused by all tests in the file.\nlet apiContext;\n\ntest.beforeAll(async ({ playwright }) => {\n  apiContext = await playwright.request.newContext({\n    // All requests we send go to this API endpoint.\n    baseURL: 'https://api.github.com',\n    extraHTTPHeaders: {\n      // We set this header per GitHub guidelines.\n      'Accept': 'application/vnd.github.v3+json',\n      // Add authorization token to all requests.\n      // Assuming personal access token available in the environment.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    },\n  });\n})\n\ntest.afterAll(async ({ }) => {\n  // Dispose all responses.\n  await apiContext.dispose();\n});\n\ntest('last created issue should be first in the list', async ({ page }) => {\n  const newIssue = await apiContext.post(`/repos/${USER}/${REPO}/issues`, {\n    data: {\n      title: '[Feature] request 1',\n    }\n  });\n  expect(newIssue.ok()).toBeTruthy();\n\n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);\n  const firstIssue = page.locator(`a[data-hovercard-type='issue']`).first();\n  await expect(firstIssue).toHaveText('[Feature] request 1');\n});\n")))),(0,i.kt)("h3",{id:"validating-postconditions"},"Validating postconditions"),(0,i.kt)("p",null,"The following test creates a new issue via user interface in the browser and then uses checks if it was created via API:"),(0,i.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { test, expect } from '@playwright/test';\n\nconst REPO = 'test-repo-1';\nconst USER = 'github-username';\n\n// Request context is reused by all tests in the file.\nlet apiContext;\n\ntest.beforeAll(async ({ playwright }) => {\n  apiContext = await playwright.request.newContext({\n    // All requests we send go to this API endpoint.\n    baseURL: 'https://api.github.com',\n    extraHTTPHeaders: {\n      // We set this header per GitHub guidelines.\n      'Accept': 'application/vnd.github.v3+json',\n      // Add authorization token to all requests.\n      // Assuming personal access token available in the environment.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    },\n  });\n})\n\ntest.afterAll(async ({ }) => {\n  // Dispose all responses.\n  await apiContext.dispose();\n});\n\ntest('last created issue should be on the server', async ({ page, request }) => {\n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);\n  await page.click('text=New Issue');\n  await page.fill('[aria-label=\"Title\"]', 'Bug report 1');\n  await page.fill('[aria-label=\"Comment body\"]', 'Bug description');\n  await page.click('text=Submit new issue');\n  const issueId = page.url().substr(page.url().lastIndexOf('/'));\n\n  const newIssue = await request.get(`https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`);\n  expect(newIssue.ok()).toBeTruthy();\n  expect(newIssue).toEqual(expect.objectContaining({\n    title: 'Bug report 1'\n  }));\n});\n"))),(0,i.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// @ts-check\nconst { test, expect } = require('@playwright/test');\n\nconst REPO = 'test-repo-1';\nconst USER = 'github-username';\n\n// Request context is reused by all tests in the file.\nlet apiContext;\n\ntest.beforeAll(async ({ playwright }) => {\n  apiContext = await playwright.request.newContext({\n    // All requests we send go to this API endpoint.\n    baseURL: 'https://api.github.com',\n    extraHTTPHeaders: {\n      // We set this header per GitHub guidelines.\n      'Accept': 'application/vnd.github.v3+json',\n      // Add authorization token to all requests.\n      // Assuming personal access token available in the environment.\n      'Authorization': `token ${process.env.API_TOKEN}`,\n    },\n  });\n})\n\ntest.afterAll(async ({ }) => {\n  // Dispose all responses.\n  await apiContext.dispose();\n});\n\ntest('last created issue should be on the server', async ({ page, request }) => {\n  await page.goto(`https://github.com/${USER}/${REPO}/issues`);\n  await page.click('text=New Issue');\n  await page.fill('[aria-label=\"Title\"]', 'Bug report 1');\n  await page.fill('[aria-label=\"Comment body\"]', 'Bug description');\n  await page.click('text=Submit new issue');\n  const issueId = page.url().substr(page.url().lastIndexOf('/'));\n\n  const newIssue = await request.get(`https://api.github.com/repos/${USER}/${REPO}/issues/${issueId}`);\n  expect(newIssue.ok()).toBeTruthy();\n  expect(newIssue).toEqual(expect.objectContaining({\n    title: 'Bug report 1'\n  }));\n});\n")))),(0,i.kt)("h2",{id:"reusing-authentication-state"},"Reusing authentication state"),(0,i.kt)("p",null,"Web apps use cookie-based or token-based authentication, where authenticated state is stored as ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"},"cookies"),". Playwright provides ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-apirequestcontext#api-request-context-storage-state"},"apiRequestContext.storageState([options])")," method that can be used to retrieve storage state from an authenticated context and then create new contexts with that state."),(0,i.kt)("p",null,"Storage state is interchangeable between ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-browsercontext",title:"BrowserContext"},"BrowserContext")," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-apirequestcontext",title:"APIRequestContext"},"APIRequestContext"),". You can use it to log in via API calls and then create a new context with cookies already there. The following code snippet retrieves state from an authenticated ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-apirequestcontext",title:"APIRequestContext"},"APIRequestContext")," and creates a new ",(0,i.kt)("a",{parentName:"p",href:"/docs/api/class-browsercontext",title:"BrowserContext"},"BrowserContext")," with that state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const requestContext = await request.newContext({\n  httpCredentials: {\n    username: 'user',\n    password: 'passwd'\n  }\n});\nawait requestContext.get(`https://api.example.com/login`);\n// Save storage state into the file.\nawait requestContext.storageState({ path: 'state.json' });\n\n// Create a new context with the saved storage state.\nconst context = await browser.newContext({ storageState: 'state.json' });\n")))}g.isMDXComponent=!0}}]);